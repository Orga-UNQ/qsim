\chapter{Contexto}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sobre la materia \orga}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conceptos importantes}

\subsection{Enfoque de Von Newmann}
Este enfoque generaliza la organización de las computadoras distinguiendo en tres partes interconectadas: La CPU (con la unidad aritmético-lógica o ALU y la unidad de control) la memoria, modulo de entrada/salida (con un bus de sistema que proporciona un medio de transporte de los datos entre las distintas partes). Con este modelo surge el concepto de programa almacenado contiene un conjunto de instrucciones que podían ser almacenadas en memoria, o sea, un programa que detalla la computación del mismo. El programa se codifica de cierta manera para que pueda ser almacenadoy posteriormente ejecutado quizas muchas veces. Ademas puede ser 'recordado' de esta manera se separa en el mecanismo de ejecución el hadware de la logica de computo o instrucciones (software).
Este tipo del diseño que permite un programa almacenado también da la posibilidad de que los programas sean modificados ellos mismos durante su ejecución, por ejemplo un programa podría modificar o incrementar las direcciones de memoria que tenga en algunas instrucciones y luego volver a ejecutar dichas instrucciones con fin de procesar celdas diferentes de memoria. Esta caracteistica es potente y a la vez peligrosa pues las modificaciones en los programas podía ser algo perjudicial, por accidente o por diseño.

\subsection{Organización de la computadora}

La CPU (Unidad Central de Procesamiento del inglés: Central Processing Unit), es el componente principal y el encargado ejecutar los programas y procesar los datos. La CPU contiene otros componentes de importancia tales como la Unidad de Control, PC, IR, Registros y la ALU.

PC: El contador de programa (en inglés Program Counter o PC) es un registro que indica la posición de memoria donde estará la siguiente instrucción que debe ejecutarse. Este registro se incrementa luego de cada ciclo de instrucción.

IR: Este registro contiene la instrucción actual una vez que la misma es leída de memoria para luego decodificarla y ejecutarla.

Registros: son elementos de una memoria de alta velocidad y poca capacidad que permite guardar y acceder a valores generalmente muy usados, por ejemplo, operandos en operaciones matemáticas. Hay diferentes tipos de registros, algunos pueden guardar tanto datos como direcciones de memoria.

ALU: es la unidad aritmético lógica, recibe su nombre de las siglas en inglés de arithmetic logic unit. La ALU es un circuito digital que lleva a cabo operaciones aritméticas (suma, resta, multiplicación, división) y las operaciones lógicas (Negacion, Y, O, O exclusivo), entre dos cadenas binarias que son interpretadas como números. 

Unidad de control: La UC dirige el ciclo de ejecución de cada instrucción, pidiendo la lectura de celdas de memoria donde esta alojada la instruccion, decodificando la instruccion y ejecutandola luego en colaboración con los otros componenetes del sistema: si es una operación lógica o aritmetica le ordena a la ALU su ejecución, si es de movimiento de datos colabora con el dispositivo de Entrada/Salida.

Memoria: es un conjunto de celdas numeradas. La numeración de cada celda la identifica inequívocamente por lo cual a esta numeración se le llama direccion. En cada celda de la memoria se pueden almacenar datos o instrucciones en forma de cadenas binarias. La información puede leerse y modificarse. En la memoria es donde se alojan los programas que luego serán ejecutados.

Buses: son los encargados de transferir los datos entre los componentes de la computadora.La unidad de control al pedir un contenido de una direccion de memoria lo hace a traves del bus, lo mismo cuando desea escribir en memoria.

\subsection{Ejecución de un programa}

La función de una computadora es la ejecución de programas. Los programas se encuentran almacenados en memoria y consisten en una sucesión de instrucciones que posee orden. La CPU es quien se encarga de ejecutar dichas instrucciones a través de un ciclo denominado ciclo instrucciones. Para ser almacenadas en memoria, las instrucciones deben codificarse en cadenas binarias (secuencias de ceros y unos) que no son legibles para las personas pero que la UC puede interpretar y traducir en acciones. Por eso para saber de qué instrucción se trata, y cuales son los valores o celdas de memoria que debería consultar o usar, la cpu utiliza la UC, que tomando bit por bit interpreta la cadena binaria y verificando los códigos únicos de cada instrucción o modos de direccionamiento, sabe qué instrucción y con qué valores debería ejecutar. La ejecución de instrucciones se divide en tres etapas importantes, fech - decode - execute.

Al principio de cada ciclo de ejecución, durante el fech de instrucción la CPU busca una instrucción que se encuentra en alguna parte de la memoria. Para saber donde esta dicha instrucción la CPU contiene un registro llamado contador de programa (PC), que tiene la dirección de la próxima instrucción a buscar. La CPU a través del bus lee la instrucción, y luego incrementa el valor contenido en PC; así podrá buscar la siguiente instrucción en la secuencia luego de terminar con la actual. La instrucción leida que está en la forma de cadena binaria se carga dentro de otro registro de la CPU, llamado registro de instrucción (IR).

Durante la decodificacion la UC determina que significa la cadena binaria.

Finalmente al saber de qué instrucción se trata la CPU ejecuta la instrucción, es decir, realiza lo que la instrucción dice que debe hacer con sus argumentos, modificando la memoria o los registros como resultado final y el ciclo vuelve a comenzar hasta que el programa termine.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Arquitecturas Q}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Características generales} \label{caracteristicasQ}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Repertorio de modos de direccionamiento}

\begin{enumerate}

\item \textbf{Inmediato}
Codigo de modo de direccionamiento: 000000
Este modo de direccionamiento es un valor que será utilizado como modo origen pero nunca como modo destino ya que en el no pueden guardarse datos.

Ejemplos:
\textbf{0x0000} representa el modo de direccionamiento inmediato cuyo valor es cero.
\textbf{0x000F} representa el modo de direccionamiento inmediato cuyo valor es 15.

\item \textbf{Directo}
Codigo de modo de direccionamiento: 001000
Este modo de direccionamiento representa una direccion de memoria o de puertos que será utilizado como modo origen pero nunca como modo destino ya que en el no pueden guardarse datos.

Ejemplos:
\textbf{[0x0000]} representa el modo de direccionamiento directo cuyo valor se encuentra en la celda de memoria que identifica uniquevocamente a la dirección \textbf{0x0000}, es decir 0.
\textbf{[0x000F]} representa el modo de direccionamiento directo cuyo valor se encuentra en la celda de memoria que identifica uniquevocamente a la dirección \textbf{0x000F}, es decir 15.

\item \textbf{Indirecto}
Codigo de modo de direccionamiento: 011000
Este modo de direccionamiento representa una direccion de memoria o de puertos que será utilizado como modo origen pero nunca como modo destino ya que en el no pueden guardarse datos.

Ejemplos:
\textbf{[[0x0000]]} representa el modo de direccionamiento indirecto cuyo valor se encuentra en la celda de memoria cuya dirección esta guardada como dato en la celda de memoria que identifica uniquevocamente a la dirección \textbf{0x0000}, es decir 0.
\textbf{[[0x000F]]} representa el modo de direccionamiento indirecto cuyo valor se encuentra en la celda de memoria cuya dirección esta guardada como dato en la celda de memoria que identifica uniquevocamente a la dirección \textbf{0x000F}, es decir 15.

\item \textbf{Registro}
Codigo de modo de direccionamiento: 100rrr 
Donde "rrr" es una cadena binaria que puede tomar los valores desde 000 hasta 111 para identificar según el numero decimal que representen los diferentes ocho registros R0..R7.

Ejemplos:
\textbf{R0} representa el modo de direccionamiento registro cuyo valor se encuentra en el registro \textbf{R0}.
\textbf{R7} representa el modo de direccionamiento registro cuyo valor se encuentra en el registro \textbf{R7}.

\item \textbf{RegistroIndirecto}
Codigo de modo de direccionamiento: 110rrr 
Donde "rrr" es una cadena binaria que puede tomar los valores desde 000 hasta 111 para identificar según el numero decimal que representen los diferentes ocho registros R0..R7.

Ejemplos:
\textbf{[R0]} representa el modo de direccionamiento registro cuyo valor se encuentra en la direccion de memoria que esta guardada como dato el registro \textbf{R0}.
\textbf{[R7]} representa el modo de direccionamiento registro cuyo valor se encuentra en la direccion de memoria que esta guardada como dato el registro \textbf{R7}.

\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Repertorio de instrucciones}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones de 2 operandos}
El formato de instruccion de dos operandos es el siguiente:

  CodOp   +  Modo destino +  Modo origen +  Destino  +   Origen
(4 bits)       (6 bits)        (6 bits)    (16 bits)    (16 bits)  

Donde el operando destino no puede ser un modo de direccionamiento Inmediato, ya que en la direccion de memoria o registro que describa dicho operando es donde se guardará el resultado de la operación.

\begin{enumerate}
\item \textbf{MUL destino, origen}
Código de operación: 0000
Esta instrucción describe la multiplicación entre los datos de los dos operandos. Esta operación es la única que cuyo resultado puede ser 32 bits, que son dos celdas de memoria en hexadecimal, por lo que los primeros 16 bits, es decir, la primer mitad, es guardada en el registro R7 y la segunda en el operando destino.
 
\item \textbf{ADD destino, origen}
Código de operación: 0010
Esta instrucción describe la suma entre los datos de los dos operandos. El resultado de la ejecución de la suma es guardado en el operando destino.

\item \textbf{SUB destino, origen}
Código de operación: 0011
Esta instrucción describe la resta entre los datos de los dos operandos. El resultado de la ejecución de dicha resta es guardado en el operando destino.

\item \textbf{DIV destino, origen}
Código de operación: 0111
Esta instrucción describe la división entre el dato en el operando destino como dividendo y el dato en el operando origen como divisor. El resultado de la ejecución de la división es guardado en el operando destino.

\item \textbf{MOV destino, origen}
Código de operación: 0001
Esta instrucción describe la copia de datos del dato alojado en el operando origen al operando destino. El resultado de la ejecución del MOV es el dato guardado en el operando origen ahora también guardado en el operando destino.

\item \textbf{AND destino, origen}
Código de operación: 0100
Esta instrucción describe la operación logica "y" bit a bit entre los datos de los dos operandos. El resultado de la ejecución de esta operación es guardado en el operando destino.

\item \textbf{CMP destino, origen}
Código de operación: 0110
Esta instrucción describe la comparación bit a bit entre los datos de los dos operandos. El resultado de esta operación es solamente la actualización de flags en la cpu.

\item \textbf{OR destino, origen}
Código de operación: 0101
Esta instrucción describe la operación logica "o" bit a bit entre los datos de los dos operandos. El resultado de la ejecución de esta operación es guardado en el operando destino.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones de 1 operando origen}

El formato de instruccion de un operando origen es el siguiente:

  CodOp   +   relleno   +  Modo origen +   Origen
(4 bits)      (000000)        (6 bits)    (16 bits)

\begin{enumerate}
\item \textbf{CALL origen}
Código de operación: 1011
El efecto del CALL es guardar la direccion de memoria en la celda de la dirección que se encuentra guardadad en el SP (Stack pointer) aumentar el SP y guardar en el PC (Program Counter) el dato que se encuentra guardado en el operando origen ya que describe el llamado a una subrutina que comienza en la celda de memoria cuya direccion esta guardada en el operando origen.

\item \textbf{JMP origen}
Código de operación: 0110
El efecto del JMP es cambiar el PC (Program Counter) por el dato que esta guardado en el operando origen ya que esta operación describe el salto a otra parte de la memoria para continuar con la ejecución del programa.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones de 1 operando destino}

El formato de instruccion de un operando destino es el siguiente:

  CodOp   +  Modo origen  +  relleno  +  Origen
(4 bits)      (6 bits)      (000000)    (16 bits)

\begin{enumerate}
\item \textbf{NOT destino}
Código de operación: 1001
Esta instrucción describe la operación logica "negación" bit a bit en el datos del operando destino. El resultado de la ejecución de esta operación es guardado en la misma celda o registro de donde es leído el dato inicialmente.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones sin operandos}

El formato de instruccion sin operandos es el siguiente:

 CodOp     +    relleno 
(4 bits)     (000000000000)


\begin{enumerate}
\item \textbf{RET}
Código de operación: 0110
El efecto del ret es cambiar el pc por el dato que esta guardado en la celda de memoria que se encuentra en el SP (Stack pointer) y decrementar el SP ya que describe la finalización de la ejecución de una subrutina y la ejecución del resto del programa.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Instrucciones de salto condicional}

El formato de instruccion de salto condicional es el siguiente es el siguiente:

 prefijo +   CodOp   +  desplazamiento 
 (1111)     (4 bits)     (8 bits)

El efecto de cualquier salto condicional es aumentar el PC (Program Counter) en la cantidad de celdas que indique el desplazamiento si sólo la condición que cada salto condicional tiene da como resultado 1, lo cual es interpretado como verdadero.

\begin{enumerate}
\item \textbf{JE desplazamiento}
Código de operación: 0001
La condición del salto es que el flag \textbf{Z} (Cero) sea 1, es decir la ultima operación matemática dió como resultado el número cero.

\item \textbf{JNE desplazamiento}
Código de operación: 1001
La condición del salto es que el flag \textbf{Z} (Cero) sea 0, es decir la ultima operación matemática no dió como resultado el número cero.

\item \textbf{JLE desplazamiento}
Código de operación: 0010
La condición del salto es el resultado de la siguiente operación lógica \textbf{Z OR ( N XOR V )}, es decir la ultima operación matemática es menor o igual con signo.

\item \textbf{JG desplazamiento}
Código de operación: 1010
La condición del salto es el resultado de la siguiente operación lógica \textbf{NOT (Z OR ( N XOR V ))}, es decir la ultima operación matemática es mayor con signo.

\item \textbf{JL desplazamiento}
Código de operación: 0011
La condición del salto es el resultado de la siguiente operación lógica \textbf{N XOR V}, es decir la ultima operación matemática es menor con signo.

\item \textbf{JGE desplazamiento}
Código de operación: 1011
La condición del salto es el resultado de la siguiente operación lógica \textbf{NOT (N XOR V)}, es decir la ultima operación matemática es mayor o igual con signo.

\item \textbf{JLEU desplazamiento}
Código de operación: 0100
La condición del salto es el resultado de la siguiente operación lógica \textbf{C OR Z}, es decir la ultima operación matemática es menor o igual sin signo.

\item \textbf{JGU desplazamiento}
Código de operación: 1100
La condición del salto es el resultado de la siguiente operación lógica \textbf{NOT (C OR Z)}, es decir la ultima operación matemática es mayor sin signo.

\item \textbf{JCS desplazamiento}
Código de operación: 0101
La condición del salto es que el flag \textbf{C} sea 1, es decir la ultima operación matemática es menor sin signo.

\item \textbf{JNEG desplazamiento}
Código de operación: 0101
La condición del salto es que el flag \textbf{N} sea 1, es decir si el último resultado de una operación dio negativo.

\item \textbf{JVS desplazamiento}
Código de operación: 0111
La condición del salto es que el flag \textbf{V} sea 1, es decir si el último resultado de una operación dio overflow.

\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Versiones de la arquitectura}

Las versiones de la arquitectura QUARQ estan pensadas para incorporar funcionalidades de manera que la curva de aprendizaje sea adecuada para los alumnos, siendo paulatina e incremental, es decir, cada arquitectura Qi agrega más funcionalidad (ya sean instrucciones nuevas o modos de direccionamiento) a las arquitecturas Qi anteriores.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Q1}

\textbf{Modos de direccionamiento}
\begin{enumerate}
\item Inmediato
\item Registro
\end{enumerate}

\textbf{Instrucciones}
\begin{enumerate}
\item MOV
\item SUB 
\item DIV 
\item ADD 
\item MUL
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Q2}

\textbf{Modos de direccionamiento}
\begin{enumerate}
\item Modos de direccionamiento \textbf{Q1}
\item Directo 
\end{enumerate}

\textbf{Instrucciones}
\begin{enumerate}
\item Instrucciones \textbf{Q1}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Q3}

\textbf{Modos de direccionamiento}
\begin{enumerate}
\item Modos de direccionamiento \textbf{Q2}
\end{enumerate}

\textbf{Instrucciones}
\begin{enumerate}
\item Instrucciones \textbf{Q2}
\item CALL
\item RET
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Q4}

\textbf{Modos de direccionamiento}
\begin{enumerate}
\item Modos de direccionamiento \textbf{Q3}
\end{enumerate}

\textbf{Instrucciones}
\begin{enumerate}
\item Instrucciones \textbf{Q3}
\item CMP
\item JMP
\item JE 
\item JNE 
\item JLE 
\item JG 
\item JL 
\item JGE 
\item JLEU 
\item JGU 
\item JCS 
\item JNEG 
\item JVS
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Q5}

\textbf{Modos de direccionamiento}
\begin{enumerate}
\item Modos de direccionamiento \textbf{Q4}
\item Idirecto
\item RegistroIdirecto
\end{enumerate}

\textbf{Instrucciones}
\begin{enumerate}
\item Instrucciones \textbf{Q4}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Q6}

\textbf{Modos de direccionamiento}
\begin{enumerate}
\item Modos de direccionamiento \textbf{Q5}
\end{enumerate}

\textbf{Instrucciones}
\begin{enumerate}
\item Instrucciones \textbf{Q5}
\item AND
\item OR
\item NOT
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Estado del arte}

