\part{Simulador \qsim}


\section{Funcionalidad del simulador}

La funcionalidad del simulador puede caracterizarse mediante las siguientes partes importantes:

\begin{itemize}
\item Chequeo de sintaxis de los programas escritos en el lenguaje Q
\item Ensamblado del código fuente de un programa en su correspondiente código máquina
\item Cargado en memoria del código máquina
\item Ejecución paso a paso de un programa cargado en memoria
\end{itemize}

\subsection{Chequeo de sintaxis}

El simulador provee al alumno de un editor de texto en el cual escribirá el programa en un lenguaje Qi, que desea cargar en memoria y ejecutar.
Una vez que el usuario haya terminado la escritura, al momento de cargar el programa, el simulador utilizará un parser para detectar errores de sintaxis, tales como la falta de una coma o un corchete, o la presencia de símbolos que no pertenecen al lenguaje (como por ejemplo signos de pregunta y símbolos matemáticos); o bien errores semánticos como la combinación incorrecta de elementos del lenguaje, por ejemplo: modos de direccionamiento mal ubicados.
El parser solo revisará lo escrito por el alumno y de acuerdo a las gramática del lenguaje, mostrará alguno de los siguientes estados:

\begin{description}
\item[OK] Este mensaje se obtiene cuando no hubo ningún error de sintaxis. Si se da este resultado, es posible continuar con el ensamblado y cargado en memoria.
\item[SyntaxError] Este mensaje de error se obtiene cuando en alguna línea del programa se detectó algún error de sintaxis o de semántica, como se describió arriba. Cuando ocurre este error se lo acompaña con una descripción lo mas detallada posible para que el alumno detecte donde ocurrió y pueda corregirlo. Un programa con errores no puede ser ensamblado y cargado en memoria.
\end{description}

\subsection{Ensamblado}

Una vez que el programa es sintácticamente válido es posible traducir el código fuente del programa en código máquina (representado en cadenas binarias). Para esto se respeta un formato de instrucción que indica cómo se codifica cada operación y los operandos. 

\ojo{Mas detalle al respecto de este proceso en la sección de ...}{Poner vínculo a donde se ponen ejemplos de Qi}

\subsection{Cargado en memoria}

Una vez ensamblado, la representación binaria (o código máquina) del programa será cargado en memoria a partir de una ubicación (celda de memoria) que el alumno puede elegir. Esto permite visualizar el contenido de la memoria (con el programa cargado) y el estado de los registros de la CPU. La decodificación con desensamblado permite al alumno experimentar otros escenarios y efectos laterares, entre los cuales podemos enumerar:

\begin{itemize}
\item Si la ejecución paso a paso excede los límites del programa, pueden tomarse instrucciones de otra rutina y procesarse como una nueva instruccion.
\item Si en cambio, se intenta ejecutar el contenido de una celda con datos (y no una instrucción) podrá ocurrir que se encuentre una instrucción invalida (combinacion de modos, codigos, incorrecta) y el alumno verá el mensaje de error pertinente.
\end{itemize}

Durante la carga del programa en memoria puede producirse un OutOfMemoryError?, que significa que el programa no entra en la ubicación elegida en memoria ya que ocupa más celdas que las que se encuentran disponibles debajo de ella ya que como se mencionó en la sección \ref{caracteristicasQ}, la memoria disponible tiene un tamaño limitado y por este motivo la alocación en memoria del código máquina puede exceder el espacio disponible a partir de la celda inicial anteriormente elegida. Si por el contrario, no se produce este error, el alumno podrá ver el programa cargado en memoria exitosamente.

\subsection{Ejecución paso a paso}

Se provee la funcionalidad de la ejecución paso a paso ya que se desea que el alumno pueda experimentar y así comprender los pasos del ciclo de ejecución. Además puede ejercitarse situaciones que se denominan ''errores conceptuales de programación'' Esto es a lo que llamamos Errores conceptuales, entre los cuales es posible mencionar:

\begin{itemize}
\item Tomar un dato de un sector de memoria equivocado.
\item Que el programa sobrescriba su mismo código máquina.
\item Permitir que la ejecución continue una vez terminado el programar cargado en memoria.
\item 
\end{itemize}

El paso a paso que provee el simulador consiste en las siguientes estapas pertenecientes al ciclo de instruccion:

\begin{enumerate}
\item \textbf{Búsqueda de instrucción:} El alumno podrá visualizar el valor que contiene PC (Program counter) donde se encuentra la dirección de la celda en memoria que contiene la próxima instrucción a ejecutar (por ejemplo, en caso de ser la primer instrucción del programa recién cargado, el pc tendrá la dirección de memoria elegida por el alumno para iniciar el cargado del programa en memoria). El simulador, toma de la memoria el código maquina correspondiente a la instrucción que comienza en esa dirección tomada de PC (una instrucción puede ocupar más de una celda de memoria) y los guarda en el \IR\ (\textit{Instruction Register}). Será observable también para el alumno el incremento del registro PC, tantas como celdas ocupe la instrucción actual, lo que conceptualmente es, preparar el contexto de ejecución para tomar la siguiente instrucción.

\item  \textbf{Decodificación:}
En la decodificación el Interprete se encarga de desensamblar el código máquina (abreviado en hexadecimal) que ya fue ubicado en el \IR para mostrar el código fuente de la instrucción actual con sus respectivos operandos. Si el programa escrito por el alumno es sintacticamente y conceptualmente correcto, este paso le permite comprobar que la instrucción actual es la que él mismo escribió y no otra, visualizandola en pantalla. En esta etapa se provee también la oportunidad de que el alumno aprecie otros conceptos, tales como los errores conceptuales mencionados antes.

\item  \textbf{Ejecución}
El execute ejecuta los efectos de la instrucción y muestra en pantalla los cambios en el estado de ejecución: memoria, puertos, registros y flags. Dentro de esta misma etapa se lleva a cabo el almacenamiento de resultados que, cuando sea necesario, guardará el valor resultante de la operación descripta por la instrucción en el operando destino. Esto cambiará el valor de una celda de memoria o de un registro y será visto en pantalla por el alumno.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{Implementación}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Tecnología utilizada (tati)}

\begin{itemize}


\item  \textbf{Scala}
Elegimos el lenguaje Scala para realizar el simulador ya que, en la materia llamada Objetos III, lo utilizamos un pequeño lapso de tiempo y creímos que era una buena oportunidad para, en vez de elegir un lenguaje que hayamos utilizado más en la carrera como java, profundizar en la utilización de Scala y aprovechar las ventajas que este ofrecia al combinar el manejo de objetos y las características de un lenguaje funcional.

\item  \textbf{Arena}
Utilizamos el framework Arena para realizar la interfaz de usuario del simulador porque es un framawork de codigo abierto, que también pudimos utilizar en una de las materias y al poder ser convinado con Scala nos pareció una buena oportunidad de explotar lo que nos ofrecia para que este simulador en su totalidad sea de codigo abierto.

\item  \textbf{Eclipse}
Se eligio utilizar el entorno de programación Eclipse ya que ambas trabajamos en diferentes sistemas operativos para los cuales Eclipse es funcional y puede tener los mismos pluggins que hace que pueda sopotar proyectos MVN y Scala, además de que, al ser el entorno de programación que más hemos usado nos sentiamos cómodas con esa elección.

\item  \textbf{Git}
Elegimos git como repositorio externo para sincronizar nuestro codigo ya que promueve el codigo abierto (ACA QUIERO PONER LO DE QUE ESTA AHI ARRIBA Y NO LE CEDEMOS DERECHOS NI NADA  A NADIE PERO NO ME SALE!!!)

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ (arq OO)}

Como se observa en la figura \ref{ALU} tiente toda la responsabilidad en la ejecución de operaciones matematicas y logicas, además del analisis sobre los flags luego de cada operación. 

\graf{ALU}{Diagrama de clase de la \ALU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{BusEntradaSalida_Memoria_CeldasPuertos} el Bus de entrada y salida tiene la responsabilidad de derivar según donde corresponda (Memoria o Puertos) la modificación de una celda o el leer un dato. Para conoce a una instancia de la clase Memoria y a otra de la clase CeldasPuertos. 
Ambas clases conocen muchas intancias de la clase Celda, y cada Celda a su vez conoce un dato: una instancia del W16, que representa a los datos guardados en memoria o en los puertos.  

\graf{BusEntradaSalida_Memoria_CeldasPuertos}{Diagrama de clase del la \BusEntradaSalida_Memoria_CeldasPuertos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{CPU}, la CPU conoce a la ALU, contiene los registros IR y PC, y los flags (V,Z,C,N) y los ocho registros (R0...R7). La responsabilidad de la CPU es actualizar los flags, los registros, actualizar el PC y el IR, y ser la conexión con la ALU.

\graf{CPU}{Diagrama de clase de la \CPU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{Interprete} el Interprete tiene la entera responsabilidad de recibir los datos leídos desde, una celda de memoria hasta tres celdas, y bit a bit, según los códigos de operación y de modo de direccionamiento saber de que instrucción se trata y cuales son sus operandos si es que los tiene y devolver el objeto que la representa. Se ocupa del decode de la instrucción.

\graf{Interprete}{Diagrama de clase de la \Interprete}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{ModoDireccionamiento} los modos de direccionamiento extienden del trait ModoDireccionamiento, donde se encuentran declarados mensajes necesarios para majear todas las subclases poliformicamente. Entre los cuales se encuentran los mensajes: 
\begin{itemize}
\item  \textbf{representacionString}
Que devuelve la representación en string como codigo fuente, por ejemplo la representación de un ADD(R0,R7), sería: ADD R0, R7
\item  \textbf{codigo}
Retorna el string que representa al código único de modo de direccionamiento, por el ejemplo, el código de modo de direccionamiento del R7 es 100111.
\item  \textbf{getValorString}
Retorna el string que representa al dato que posee el modo de direccionamiento. En el caso de un Inmediato que sea FF56, devolvera el string "FF56", y en el caso de cualquier registro, retornara el valor que represente su W16.
\end{itemize}
Los modos de direccionamiento diferentes a Inmediato y Registro, conocen en vez de un W16 otro modo de direccionamiento según corresponda:
\begin{itemize}
\item RegistroIndirecto conoce un a instancia de Registro.
\item Directo conoce conoce un a instancia de Inmediato.
\item Indirecto conoce conoce un a instancia de Directo.
\end{itemize}
Esto se implemento de esta manera para que el leer datos de memoria, puertos o registros, o guardarlos en los mismos sea más sencillo ya que se delega en el modo de direccionamiento que conoce.

La clase Etiqueta representa la etiqueta creada por el alumno cuando realiza el programa. Cuando el mismo es cargado en memoria, según cual sea la celda de inicio y cuanto ocupen las instruciones, se calcula la dirección de memoria que representa la etiqueta y luego se descarta reemplazandola por un modo de direccionamiento Inmediato.

La clase W16 que también esta en la figura \ref{ModoDireccionamiento}, representa el dato que es guardado en memoria. Tiene la responsabilidad de incrementarse, decrementarse, sumar una entero, devolver su representación binria y su valor en entero.


\graf{ModoDireccionamiento}{Diagrama de clase de la \ModoDireccionamiento}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{ALU}

\graf{ALU}{Diagrama de clase de la \ALU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{ALU}

\graf{ALU}{Diagrama de clase de la \ALU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{ALU}

\graf{ALU}{Diagrama de clase de la \ALU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{ALU}

\graf{ALU}{Diagrama de clase de la \ALU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Como se observa en la figura \ref{ALU}

\graf{ALU}{Diagrama de clase de la \ALU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Como se observa en la figura \ref{ALU}

\graf{ALU}{Diagrama de clase de la \ALU}

%[width=0.7\textwidth]



