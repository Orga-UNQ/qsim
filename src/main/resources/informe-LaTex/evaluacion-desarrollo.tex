\part{Evaluación del desarrollo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55
\section{Dificultades encontradas}

\subsection{Dificultades presentadas por el dominio}
Las dificultades del dominio estuvieron relacionadas a la comprensión no solamente del modelo de arquitectura Q si no también a su propósito didáctico, ya que el objetivo del simulador no es solamente la simulación de la arquitectura y la ejecución de programas, sino también el proveer a los alumnos la capacidad de ejercitar situaciones conceptualmente erróneas, por lo que se requería una comprensión didáctica del problema más allá de la especificación de las arquitecturas Q. 

\subsection{Dificultades de diseño}
En primera instancia se optó por implementar un modelo de objetos que utilizaba un objeto de la clase \textbf{Programa} a lo largo de toda la ejecución.Esto implica que no leía de la memoria principal las instrucciones a ejecutar, sino que solicitaba la siguiente instrucción al objeto instancia de la clase Programa, sobreviviendo así las distintas etapas una vez que fue creado por el \textit{parser}. Este enfoque evitaba la creación de un objeto que tuviera que interpretar el código máquina alojado en la memoria, evitaba la nueva creación de instancias de la clase \textbf{Instrucción} y simplificaba en gran medida el modelo ya que la memoria era sólo una clase que contenía datos que se reflejaban en pantalla y no se extraían datos de celdas en ningún momento. Luego entendimos que un programa no sólo podía modificar su entorno al ser ejecutado (otras celdas de memoria que no ocupen su código maquina, celdas de puertos, registros, etc) si no que también podría sobrescribir su código maquina (ya sea con ese propósito o sólo por un error conceptual), o bien, que el alumno debía tener la posibilidad de seguir ejecutando más allá del código máquina alojado en memoria o más. A partir de eso fue necesario corregir gran parte del modelo agregando una clase denominada \textbf{Intérprete}, cuya responsabilidad es interpretar la siguiente instrucción alojada en memoria para que luego sea ejecutada, otorgando más responsabilidad a la clase \textbf{Memoria} y descartando el objeto instancia de \textbf{Programa} una vez que éste es cargado en memoria con éxito.\\

Por otro lado, tuvieron que solicitarse extensiones al equipo de desarrolladores de Arena para poder realizar la interfaz con dicho framework:

\begin{itemize}
\item FileSelector para que los alumnos puedan cargar el archivo .Qsim en el cual se encuentra su programa
\item CodeEditor (O actualmente llamado KeywordTextArea). Es el espacio donde se visualiza el programa Qi que realizaron los alumnos una vez que esta cargado.
\item Bindings contra el background de componentes y celdas de una tabla, para permitir la visualización de cambios de colores en la memoria luego de las etapas de ejecución y de realizar algún cambio en la misma.
\item TexBox multiLine (TextArea) con scroll para ser utilizado como consola de devolucion.
\item Icono para la aplicación, solo por cuestiones estéticas.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55
\section{Casos de prueba (revisar redaccion!!)}

En esta sección se describen los casos de prueba de la aplicación realizados para ilustrar el alcance de la aplicación y su robustez.

\subsection{Chequeo de sintaxis en la distintas Qi}

El chequeo de sintaxis de cada \textbf{Arquitectura Q} se reliza primero escribiendo un programa Qi en un archivo con extension .qsim y luego, haciendo que este mismo archivo sea tomado por el objeto Parser cuya responsabilidad es chequear la sintaxis. 

Para chequear la sintaxis de cada \textbf{Arquitectura Q} se realizaron dos casos de prueba por cada Qi:
\begin{enumerate}
\item \textbf{Chequear programa Qi válido}

Se toma como input del objeto instancia Parser un programa Qi válido\footnote{Un programa Qi válido es un programa sintáticamente correcto en alguna arquitectura Q.}, este chequeará la sintaxis del programa acorde a la arquitectura Qi seleccionada (Un programa sintácticamente válido en Q6 puede no ser sintácticamente válido en Q1 si utiliza modos de direccionamiento o instrucciones que aún no fueron agregadas en Q1). Al terminar de chequear el programa, el objeto parser retorna un objeto instancia de la clase Programa con la lista de instrucciones que fueron ensambladas. 
Se toma dicho resultado y como ultimo paso se compara si el programa resultado es igual al programa esperado (que concuerda en objetos con el programa en código fuente escrito en el input).


\item \textbf{Chequear programa Qi es invalido} 

Se toma como input del objeto instancia Parser un programa Qi invalido, este chequeará la sintaxis del programa acorde a la arquitectura Qi seleccionada. Al terminar de chequear el programa, el objeto parser retorna un Exception del tipo \textbf{SyntaxErrorException}, se captura la excepción y se toma de ella el mensaje de error para corroborar que sea el mensaje esperado (que describe la línea donde esta el error de sintáxis).


\subsection{Ensamblado}

Para poder verificar que el Ensamblado se realizo correctamente tomamos el programa Qi mencionado anteriormente y como sabemos que el resultado del parser nos devuelve un objeto de la clase \textbf{Programa} que contiene un conjunto de objetos de la clase \textbf{Instruccion}, el ensamblado simplemente lo realiza cada instrucción, esto quiere decir que cada instrucción tiene el comportamiento para generar su propio \codmaq. De esta forma realizamos el ensamblado del programa y obtenemos una lista de código maquina como resultado y como ultimo paso comparamos la lista de código maquina resultado con la lista código maquina esperado.

\subsection{Decodificación}

La Decodificación se verifica correctamente a la inversa del Ensamblado: tomando como input el ensamblado de un programa Qi que es la secuencia de código maquina, la cual se itera para pasar cada elemento al objeto Interprete que es el encargado de Decodificar. Como resultado de cada iteración puede retornar dos cosas:
 
\begin{enumerate}
\item \textbf{Lista de Instrucciones} 

Este es el resultado de Intrepretar una secuencia de código máquina que representa correctamente a una instruccion y sus respectivos operandos. El objeto interprete verifica los códigos de operación para poder crear las instrucciones correctamente, y luego, depende de que tipo de instruccion se haya comenzado a interpretar comienza a interpretar sus respectivos operandos (si los tiene).
Por último se compara cada instruccion en la lista resultante luego de intrepretar todo el programa con la lista esperada.

\item\textbf{Error}

Al Intrepretar una secuencia de código máquina que no representa a ninguna instruccion (ya sea porque el código de operación o el código de algún modo de direccionamiento dentro del formato de cada instrucción es invalido) es una Exepcion del tipo \textbf{CodigoInvalidoException}.   
\end{enumerate}

\subsection{Ejecución}

Para verificar que la ejecución de un programa Qi fue necesario separar la verificación en los tres pasos del \textbf{Ciclo de Instrucción}:

\begin{itemize}
\item \textbf{Fetch} 

Para verificar el fetch se toma la instrucción siguiente a ejecutar y se compara el valor que se guarda en el registro \IR con el valor esperado que debería tener (es decir, con el código maquina que representa a la instruccion siguiente a ejecutar). Ademas se verifica que el registro especial \PC tenga como valor la dirección de memoria de la siguiente instrucción a ejecutar, para corroborar esto se compara el \PC luego del fetch con \PC anterior más la cantidad de celdas que ocupa la instrucción actual.

\item \textbf{Decode}

Para verificar el decode, se toma el valor que esta guardado registro \IR para que lo reciba el interprete que retornará el objeto instrucción interpretado a partir de ese valor. Al obtener dicha instrucción se compara con la instrucción esperada.
 
\item \textbf{Execute}

Para verificar el efecto de cada instrucción se preparó un caso de prueba por cada instrucción donde, para cada instrucción se tiene un estado inicial y un estado final esperado. Se realiza la ejecución de dicha instrucción y se compara el resultado obtenido (ya sea la modificación de flags, registros, celdas de memoria o puertos) con el resultado esperado. 

\end{itemize}

\textbf{Las siguiente secciones son pasos que se realizan de acuerdo al efecto de la instrucción}
  
\subsubsection{Operaciones de ALU}

La ALU es la encargada de ejecutar operaciones aritméticas/lógicas. Si la instrucción a ejecutar tiene un efecto aritmético/lógico se le delega la ejecución de la operación. Para poder verificar todas las operaciones creamos un caso de prueba por cada operación. Tanto las operaciones aritméticas como las lógicas se analizan de la misma forma:

\begin{enumerate}
\item Se toma cada valor de los operandos(la búsqueda se detalla el la siguiente instrucción)

\item Se realiza la operación aritmética/lógica. 

\item Se verifica el resultado obtenido con el resultado esperado.

\item Algunas operaciones (la mayoría) modifican los flags. la ALU tiene mucha relación con los flags ya que por cada cuenta realizada actualiza los mismos. Estos también se se verifican comparando el resultado obtenido con el valor esperado. 
\end{enumerate}

\subsubsection{Búsqueda de Operandos}

Para verificar la búsqueda de operandos, tomamos una instrucción cualquiera y probamos todas las combinaciones de modos de direccionamiento para cada operando, teniendo en cuenta que son invalidas todas las combinaciones de 1/2 operando/s que tenga el operando destino el modo de direccionamiento Inmediato. Al tener la instrucción elegida procedemos a obtener el valor de cada operando, este valor se lo compara con el valor esperado. 
 
\subsubsection{Almacenamiento de Operandos}

Para verificar el almacenamiento de operandos, salvo algunas instrucciones todas pasan por la etapa de store.
Tomamos cada una de las instrucciones de un programa Qi y realizamos el ciclo de ejecución mencionado anteriormente.
Cuando estamos en la etapa de ejecución, cada una tiene un operando destinado a guardar el resultado de su efecto.
En esta instancia sabemos que  dicho operando tiene el valor guardado, a este valor lo comparamos con el valor esperado.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55
\section{Ejemplos de uso (Revisar!!)}

En esta sección vamos a mostrar las diferentes situaciones que pueden ocurrir a la hora de utilizar el simulador.

\subsection{Para Experimentar}

Esta sección describe situaciones particulares que los alumnos pueden experimentar.

\begin{itemize}

\item Dado el siguiente programa Qi:

\begin{verbatim}
ADD R0, [0x0002]
MUL R4, 0x0001
SUB [0x0003], 0x000A
MOV R5, 0x0056
MOV [0x0005], etiqueta
CALL [0x0005]
etiqueta: ADD R0, 0x0002
RET
\end{verbatim}

Lo interesante es que luego de ejecutar el CALL se ejecuta la instrucción ADD R0, 0x0002 y el RET. Cuando vuelve para ejecutar la próxima instrucción el PC se encuentra en la linea 7, donde vuelve a ejecutar la instrucción ADD antes mencionada. Ya lo ultimo que le queda es ejecutar el RET.
Vamos a hacer un mapa del estado del registro SP antes de seguir: Antes de ejecutar el RET  el registro SP tiene el valor inicial que es FFEF, luego en la ejecución lo primero que se hace es incrementar el SP osea que ahora tiene el valor FFFO y luego buscar el valor de esa dirección para actualizar el registro PC. Para informarles la dirección FFFO es un puerto de E/S. La conclusión es que en esta instancia el flujo de ejecución del programa depende del valor que tiene ese puerto, puede pasar que el valor sea 0x0000 y se actualice el PC nos lleve al inicio de la memoria donde se encuentra inicializado otro programa y empiece a ejecutar desde allí. 


\item Dado el siguiente programa Qi:

\begin{verbatim}
ADD R0, [0x0002]
MUL R4, 0x0001
SUB [0x0003], 0x000A 
\end{verbatim}

Pensemos que el PC se posiciona en la linea 3 y realizamos el ciclo de instrucción(FETCH - DECODE - EXECUTE). Como estado final tenemos el efecto de la ultima instrucción y el valor de PC apuntando a la siguiente instrucción a ejecutar. Como verán el programa que escribió el alumno termino en la la linea 3 pero el simulador no para de ejecutar, por ende te permite realizar las veces que quiera el ciclo de instrucción. Es re interesante que los chicos experimenten este tipo de cosas.

\end{itemize} 

\verde{La decodificación con desensamblado permite al alumno experimentar otros escenarios y efectos laterales, entre los cuales podemos enumerar:

\begin{itemize}
\item Si la ejecución paso a paso excede los límites del programa, pueden tomarse instrucciones de otra rutina y procesarse como una nueva instruccion.
\item Si en cambio, se intenta ejecutar el contenido de una celda con datos (y no una instrucción) podrá ocurrir que se encuentre una instrucción invalida (por ejemplo, una combinación incorrecta de modos de direccionamiento y códigos de operación) y el alumno verá el mensaje de error pertinente.
\end{itemize}}{ACOMODAR!!!}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Trabajo Futuro}

En esta sección se describirán características y funcionalidades que deseamos agregar al Simulador QSim en el futuro.

\begin{itemize}

\item Habilitar las instrucciones PUSH y POP.

Estas instrucciones permiten el manejo de la Pila como estructura de datos disponible para el programador. 
PUSH tiene como efecto agregar el valor del operando origen a la pila. 
POP permite sacar el primer elemento de la pila y guardarlo en el operando destino.
Actualmente estas instrcucciones se encuentran implementadas pero no habilitadas en ninguna gramática Qi.

\item Entrada y Salida.

Que el simulador admita la interacción con dispositivos de E/S. Para eso tenemos que modelar dispositivos como el teclado, impresora, monitor, etc.

\item Implementar interrupcciones

\end{itemize}
